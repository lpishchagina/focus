#' @title generate_ts Data generating function
#'
#' @description the function generates a time series of length 'n' in dimension 'p'
#' where each data point is generated by a distribution from the natural exponential family:
#' Gauss, Poisson or Pascal with a given values of means and changes.
#' 
#' @param type type of distribution: "gauss", "poisson", "pascal".
#' @param n number of data points.
#' @param p parameter of dimension.
#' @param change index of change point ( 1 < change < n).
#' @param changes a vector of increasing change point indices (last element is always less then n).
#' By default, 'changes = NULL' (the data without change points).
#' @param means matrix of successive means for data
#' By default 'means = matrix(0, ncol = 1, nrow = p)'.
#' @param noise standard deviation of an additional normal noise
#' By default 'noise = 1' (use for Gaussian distribution).
#' @param r integer-valued stopping-time parameter.
#' By default 'r = 1' (use for negative binomial distribution).
#'
#' @return matrix of data of dimension n x p with a given values of theta and theta0 for the segments.
#'
#' @examples
#' set.seed(21)
#' N <- 100
#' P <- 2
#' Change <- N %/% 2
#' theta0 <-  rep(0, P)
#' 
#' ts_gauss <- generate_ts(type = "gauss", p = P, n = N, changes = Change, means = matrix(c(theta0, theta0 + 5), nrow = P))
#' ts_poisson <- generate_ts(type = "poisson", p = P, n = N, changes = Change,  means = matrix(c(theta0 + 1, theta0 + 5), nrow = P))
#' ts_pascal <- generate_ts(type = "pascal", p = P, n = N, changes = Change,  means = matrix(c(theta0 + 0.2, theta0 + 0.7), nrow = P), r = 3)
#' 
#' ts_gauss0 <- generate_ts(type = "gauss", p = P, n = N, changes = NULL, means = matrix(0, ncol = 1, nrow = P))
#' ts_poisson0 <- generate_ts(type = "poisson", p = P, n = N, changes = NULL, means = matrix(1, ncol = 1, nrow = P))
#' ts_pascal0 <- generate_ts(type = "pascal", p = P, n = N, changes = NULL, means = matrix(0.5,  ncol = 1, nrow = P))
generate_ts <- function(type, 
                        p, 
                        n, 
                        changes, 
                        means, 
                        noise = 1, 
                        r = 1) {
  #parameter's check----------------------------- 
  if (!type %in% c("gauss", "poisson", "pascal"))
    stop('Attention, type should be "gauss", "poisson" or "pascal"!')
  
  if (!is.null(changes) && n <= changes[length(changes)]) 
    stop('Attention, the last element of changepoints is always less than n!')
  
  if(!is.null(changes) && !is.numeric(changes)) 
    stop('Attention, changes are not all numeric!')
  
  if(is.unsorted(changes)) 
    stop('Attention, changes should be an increasing vector!')
  
  if(!is.numeric(means))
    stop('means are not all numeric!')
  
  if ((length(changes) + 1) !=  length(means[1,])) 
    stop('The length of the means[,] is always equal to the number of changes plus one!')
  
  if (!is.double(noise)) 
    stop('noise is not a double!')
  
  if (noise < 0) 
    stop('noise must be non-negative!')
  
  if (!r%%1 == 0) 
    stop('r is not a integer!')
  
  if (type == "poisson") 
    if (sum(means <= 0) != 0)
      stop('Attention, the value of means shold be positive!')
  
  if (type == "pascal")
    if ((sum(means <= 0) + sum(means >=1)) != 0)
      stop('Attention, the value of means shold be in interval (0,1)!')
  #--------------------
  #data generation
  res <- matrix(0, n, p)
  for (i in 1:p) {
    parameters <- rep(means[i,], diff(c(0, changes, n)))
    if (type == "gauss")  res[, i] <- parameters + rnorm(n, 0, noise)
    if (type == "poisson") res[, i] <- rpois(n, parameters)
    if (type == "pascal") res[, i] <- rnbinom(n, size = r, prob = parameters)
  }
  return(res)
}
