library(geometry)
#' @title generate_ts Data generating function
#'
#' @description the function generates a time series of length 'n' in dimension 'p'
#' where each data point is generated by a distribution from the natural exponential family:
#' Gauss, Poisson or Pascal with a given values of means and changes.
#' 
#' @param type type of distribution: "gauss", "poisson", "pascal".
#' @param n number of data points.
#' @param p parameter of dimension.
#' @param change index of change point ( 1 < change < n).
#' @param changes a vector of increasing change point indices (last element is always less then n).
#' By default, 'changes = NULL' (the data without change points).
#' @param means matrix of successive means for data
#' By default 'means = matrix(0, ncol = 1, nrow = p)'.
#' @param noise standard deviation of an additional normal noise
#' By default 'noise = 1' (use for Gaussian distribution).
#' @param r integer-valued stopping-time parameter.
#' By default 'r = 1' (use for negative binomial distribution).
#'
#' @return matrix of data of dimension n x p with a given values of theta and theta0 for the segments.
#'
#' @examples
#' set.seed(21)
#' N <- 100
#' P <- 2
#' Change <- N %/% 2
#' theta0 <-  rep(0, P)
#' 
#' ts_gauss <- generate_ts(type = "gauss", p = P, n = N, changes = Change, means = matrix(c(theta0, theta0 + 5), nrow = P))
#' ts_poisson <- generate_ts(type = "poisson", p = P, n = N, changes = Change,  means = matrix(c(theta0 + 1, theta0 + 5), nrow = P))
#' ts_pascal <- generate_ts(type = "pascal", p = P, n = N, changes = Change,  means = matrix(c(theta0 + 0.2, theta0 + 0.7), nrow = P), r = 3)
#' 
#' ts_gauss0 <- generate_ts(type = "gauss", p = P, n = N, changes = NULL, means = matrix(0, ncol = 1, nrow = P))
#' ts_poisson0 <- generate_ts(type = "poisson", p = P, n = N, changes = NULL, means = matrix(1, ncol = 1, nrow = P))
#' ts_pascal0 <- generate_ts(type = "pascal", p = P, n = N, changes = NULL, means = matrix(0.5,  ncol = 1, nrow = P))
generate_ts <- function(type, 
                        p, 
                        n, 
                        changes, 
                        means, 
                        noise = 1, 
                        r = 1) {
  #parameter's check----------------------------- 
  if (!type %in% c("gauss", "poisson", "pascal"))
    stop('Attention, type should be "gauss", "poisson" or "pascal"!')
  
  if (!is.null(changes) && n <= changes[length(changes)]) 
    stop('Attention, the last element of changepoints is always less than n!')
  
  if(!is.null(changes) && !is.numeric(changes)) 
    stop('Attention, changes are not all numeric!')
  
  if(is.unsorted(changes)) 
    stop('Attention, changes should be an increasing vector!')
  
  if(!is.numeric(means))
    stop('means are not all numeric!')
  
  if ((length(changes) + 1) !=  length(means[1,])) 
    stop('The length of the means[,] is always equal to the number of changes plus one!')
  
  if (!is.double(noise)) 
    stop('noise is not a double!')
  
  if (noise < 0) 
    stop('noise must be non-negative!')
  
  if (!r%%1 == 0) 
    stop('r is not a integer!')
  
  if (type == "poisson") 
    if (sum(means <= 0) != 0)
      stop('Attention, the value of means shold be positive!')
  
  if (type == "pascal")
    if ((sum(means <= 0) + sum(means >=1)) != 0)
      stop('Attention, the value of means shold be in interval (0,1)!')
  #--------------------
  #data generation
  res <- matrix(0, n, p)
  for (i in 1:p) {
    parameters <- rep(means[i,], diff(c(0, changes, n)))
    if (type == "gauss")  res[, i] <- parameters + rnorm(n, 0, noise)
    if (type == "poisson") res[, i] <- rpois(n, parameters)
    if (type == "pascal") res[, i] <- rnbinom(n, size = r, prob = parameters)
  }
  return(res)
}
##CH
get_indeces_of_CH <- function(data){
  return(sort(unique(as.vector(convhulln(data)))))
}
#get_indeces_of_CH(data)





##simpleCH_utils.R
simpleChecks <- function(n, p, common_difference_step=1, common_ratio_step=2){
  data <- matrix(rnorm(n*p), ncol=p, nrow=n)
  ## Run FocusCH with Focus0 cost
  tps_focus <- system.time(list_cand <- FocusCH(data, fun.cost=cost_Focus0,   common_difference_step=1, common_ratio_step=2, first_step_qhull=ncol(data)+2))
  
  ## Sanity Checks
  ## 1) run convex hull on the whole cumsum matrix and check we recover the same candidate
  data_cumsum_square_ <- cumsum(rowSums(data^2))
  data_cumsum_ <- apply(cbind(1, data), 2, cumsum)
  tps_hull <- system.time(all_hull <- convhulln(data_cumsum_)) 
  in_the_hull <- sort(unique(as.vector(all_hull)))
  check1 <- all.equal(in_the_hull, list_cand$index[1:list_cand$nb])
  
  ## 2) run cost on the whole cumsum matrix and check we recover the same
  i <- n
  cost_cand_ <- cost_Focus0(data_cumsum_[1:n, ], data_cumsum_square_[n])
  check2 <- min(cost_cand_) == list_cand$opt.cost[n]
  data.frame(n=n, p=p, tps_md_focus=tps_focus[3], tps_convex_hull=tps_hull[3], check_hull=check1, check_cost=check2, nb_candidate=list_cand$nb, nb_hull=length(in_the_hull), nb_faces=nrow(all_hull))
}



##SimpleCH
###################################################################################################################################
#' @title cost_Focus0
#'
#' @description Function to return the l2-cost (assuming first segment mean = 0) given the left_cumsum matrix of all considered changes
#' @param left_cumsum leftcumsum of
#' @param sum_squares 
#' @return cost of all considered changes
#' @export
cost_Focus0 <- function(left_cumsum, sum_squares){
  cand <- 1:(nrow(left_cumsum)-1)
  right_cumsum <- scale(left_cumsum, left_cumsum[nrow(left_cumsum), ], scale=F)
  -rowSums(right_cumsum[cand, 2:ncol(right_cumsum), drop=FALSE]^2) / abs(right_cumsum[cand, 1]) + sum_squares
}

###################################################################################################################################
#' @title cost_Focus
#'
#' @description Function to return the l2-cost given the left_cumsum matrix of all considered changes
#' @param left_cumsum 
#' @param sum_squares 
#' @return cost of all considered changes
#' @export
cost_Focus <- function(left_cumsum, sum_squares){
  cand <- 1:(nrow(left_cumsum)-1)
  right_cumsum <- scale(left_cumsum, left_cumsum[nrow(left_cumsum), ], scale=F)
  ncand <- nrow(left_cumsum)-1
  -rowSums(right_cumsum[cand, 2:ncol(right_cumsum), drop=FALSE]^2) / abs(right_cumsum[cand, 1]) -  
    rowSums(left_cumsum [cand, 2:ncol(left_cumsum) , drop=FALSE]^2) / abs(left_cumsum[cand, 1]) + sum_squares
}



###################################################################################################################################
#' @title FocusCH
#'
#' @description Function to run md_focus0 using the convex-hull algorithm of qhull
#' @param data
#' @param fun.cost either cost_Focus0 or cost_Focus
#' @param ari_step 
#' @param geo_step
#' @param first_step_qhull
#' @return cost of all considered changes
#' @export
## ari_step and geo_step = how we compute the time we use qhull
## first_step_qhull initial use of qhull
FocusCH <- function(data, fun.cost=cost_Focus0, common_difference_step=1, common_ratio_step=1, first_step_qhull=ncol(data)+5){
  
  n <- nrow(data)
  p <- ncol(data)
  
  ## compute sum of SQ, add 1s and compute cumsum
  data_cumsum_square <- cumsum(rowSums(data^2))
  data     <- cbind(1, data)
  data_left_cumsum  <- apply(data, 2, cumsum)
  
  
  ## Initialize list of candidates 
  list_cand                     <- list(index=integer(n), nb=0, nb_at_step=integer(n),
                                        opt.cost=numeric(n), opt.change=integer(n))
  list_cand$nb                  <- list_cand$nb +1;
  list_cand$index[list_cand$nb] <- 1;
  list_cand$nb_at_step[1]       <- 1
  
  next_step_qhull <- first_step_qhull
  ## For loop
  for(i in 2:n){  ## start at 2 
    ## add a candidate
    list_cand$nb                  <- list_cand$nb +1;
    list_cand$index[list_cand$nb] <- i;
    list_cand$nb_at_step[i]       <- list_cand$nb
    
    
    ## Index and maximization
    index_cand <- list_cand$index[1:list_cand$nb]
    left_mean  <- data_left_cumsum[index_cand, ]
    ##cost_cand               <- cost_Focus0(left_mean, data_cumsum_square[i])
    cost_cand               <- fun.cost(left_mean, data_cumsum_square[i])
    list_cand$opt.cost[i]   <- min(cost_cand)
    list_cand$opt.change[i] <- index_cand[which.min(cost_cand)]
    
    ## Run qhull
    if(list_cand$nb >= next_step_qhull | i == n){
      ## Qhull
      if (list_cand$nb > p) {
        hull <- convhulln(left_mean)
        ## Prune
        on_the_hull <- sort(unique(as.vector(hull)))
        list_cand$nb <- length(on_the_hull)
        list_cand$index[1:list_cand$nb] <- index_cand[on_the_hull];
        
        ## update-next_step_qhull
        next_step_qhull <- common_ratio_step*list_cand$nb + common_difference_step
      }
    }
  }
  return(list_cand)
}

